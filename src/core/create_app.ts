import * as fs from 'fs';
import { posixify, stringify, walk, write_if_changed } from '../utils';
import { ManfiestDataPage, PageComponent, CodegenManifest } from '../interfaces';
import { compile as svelte_compile } from 'svelte/compiler';
import { CompileOptions } from 'svelte/types/compiler/interfaces';

export function create_app({
	bundler,
	manifest_data,
	dev_port,
	dev,
	has_service_worker,
	template_path,
	routes_alias,
	output,
}: {
	bundler: string,
	manifest_data: CodegenManifest;
	dev_port?: number;
	dev: boolean;
	has_service_worker: boolean;
	template_path: string;
	routes_alias: string;
	output: string;
}) {
	if (!fs.existsSync(output)) fs.mkdirSync(output);

	function get_file(path_to_routes: string, component: PageComponent) {
		if (component.default) return `./${component.type}.svelte`;
		return posixify(`${path_to_routes}/${component.file}`);
	}

	// webpack has its own loader
	const shimport_version = bundler === 'webpack' ? null : require('shimport/package.json').version

	const client_manifest = generate_client_manifest(manifest_data, routes_alias, bundler, get_file, dev, dev_port);
	const server_manifest = generate_server_manifest(manifest_data, routes_alias, template_path, dev, has_service_worker, shimport_version, get_file);

	const app = generate_app(manifest_data, routes_alias, get_file);

	write_if_changed(`${output}/internal/manifest-client.mjs`, client_manifest);
	write_if_changed(`${output}/internal/manifest-server.mjs`, server_manifest);
	write_if_changed(`${output}/internal/App.svelte`, app);
}

// todo split this into client and server...
export function app_codegen({
	prefix,
	bundler,
	manifest_data,
	dev_port,
	dev,
	has_service_worker,
	template_path,
	routes_alias,
	svelte_options,
}: {
	prefix: string;
	bundler: string;
	manifest_data: CodegenManifest;
	dev_port?: number;
	dev: boolean;
	has_service_worker: boolean;
	template_path: string;
	routes_alias: string;
	svelte_options: CompileOptions;
	}): Record<string, () => Promise<string>> {
	// webpack has its own loader
	const shimport_version = bundler === 'webpack' ? null : require('shimport/package.json').version
	
	function get_file(path_to_routes: string, component: PageComponent) {
		if (component.default) return `${prefix}internal/${component.type}.svelte`;
		return posixify(`${path_to_routes}/${component.file}`);
	}

	return {
		[`${prefix}internal/manifest-client`]: async () => generate_client_manifest(manifest_data, routes_alias, bundler, get_file, dev, dev_port),
		[`${prefix}internal/manifest-server`]: async () => generate_server_manifest(manifest_data, routes_alias, template_path, dev, has_service_worker, shimport_version, get_file),
		[`${prefix}internal/App.svelte`]: async () => {
			const source = generate_app(manifest_data, routes_alias, get_file)
			const { js } = svelte_compile(source, svelte_options)
			return js.code
		},
	}
}

export function create_serviceworker_manifest({ manifest_data, output, client_files, static_files }: {
	manifest_data: CodegenManifest;
	output: string;
	client_files: string[];
	static_files: string;
}) {
	let files: string[] = ['service-worker-index.html'];

	if (fs.existsSync(static_files)) {
		files = files.concat(walk(static_files));
	} else {
		// TODO remove in a future version
		if (fs.existsSync('assets')) {
			throw new Error(`As of Sapper 0.21, the assets/ directory should become static/`);
		}
	}

	let code = `
		// This file is generated by Sapper — do not edit it!
		export const timestamp = ${Date.now()};

		export const files = [\n\t${files.map((x: string) => stringify(x)).join(',\n\t')}\n];
		export { files as assets }; // legacy

		export const shell = [\n\t${client_files.map((x: string) => stringify(x)).join(',\n\t')}\n];

		export const routes = [\n\t${manifest_data.pages.map((r: ManfiestDataPage) => `{ pattern: ${r.pattern} }`).join(',\n\t')}\n];
	`.replace(/^\t\t/gm, '').trim();

	write_if_changed(`${output}/service-worker.js`, code);
}

function create_param_match(param: string, i: number) {
	return /^\.{3}.+$/.test(param)
		? `${param.replace(/.{3}/, '')}: d(match[${i + 1}]).split('/')`
		: `${param}: d(match[${i + 1}])`
}

function generate_client_manifest(
	manifest_data: CodegenManifest,
	path_to_routes: string,
	bundler: string,
	get_file: (path_to_routes: string, component: PageComponent) => string,
	dev: boolean,
	dev_port?: number,
) {
	const page_ids = new Set(manifest_data.pages.map(page =>
		page.pattern.toString()));

	const server_routes_to_ignore = manifest_data.server_routes.filter(route =>
		!page_ids.has(route.pattern.toString()));

	const component_indexes: Record<string, number> = {};

	const components = `[
		${manifest_data.components.map((component, i) => {
			const annotation = bundler === 'webpack'
				? `/* webpackChunkName: "${component.name}" */ `
				: '';

			const source = get_file(path_to_routes, component);

			component_indexes[component.name] = i;

			return `{
					js: () => import(${annotation}${stringify(source)}),
					css: "__SAPPER_CSS_PLACEHOLDER:${stringify(component.file, false)}__"
				}`;
		}).join(',\n\t\t\t\t')}
	]`.replace(/^\t/gm, '');

	let needs_decode = false;

	let routes = `[
				${manifest_data.pages.map(page => `{
					// ${page.parts[page.parts.length - 1].component.file}
					pattern: ${page.pattern},
					parts: [
						${page.parts.map(part => {
							if (part === null) return 'null';

							if (part.params.length > 0) {
								needs_decode = true;
								const props = part.params.map(create_param_match);
								return `{ i: ${component_indexes[part.component.name]}, params: match => ({ ${props.join(', ')} }) }`;
							}

							return `{ i: ${component_indexes[part.component.name]} }`;
						}).join(',\n\t\t\t\t\t\t')}
					]
				}`).join(',\n\n\t\t\t\t')}
	]`.replace(/^\t/gm, '');

	if (needs_decode) {
		routes = `(d => ${routes})(decodeURIComponent)`
	}

	return `
		// This file is generated by Sapper — do not edit it!
		// webpack does not support export * as root_comp yet so do a two line import/export
		import * as root from '${stringify(get_file(path_to_routes, manifest_data.root), false)}';
		export { root };

		import * as error from '${stringify(get_file(path_to_routes, manifest_data.error), false)}';
		export { error };

		export const ignore = [${server_routes_to_ignore.map(route => route.pattern).join(', ')}];

		export const components = ${components};

		export const routes = ${routes};

		${dev ? `

if (typeof window !== 'undefined') {
let source;
let nonce;

function connect(port) {
	function check() {
		if (typeof module === 'undefined') return;

		if (module.hot.status() === 'idle') {
			module.hot.check(true).then(modules => {
				console.log("[SAPPER] applied HMR update");
			});
		}
	}

	if (source || !window.EventSource) return;

	const url = port ?
		\`http://\${window.location.hostname}:\${port}/__sapper__\` :
		\`http://\${window.location.host}/__sapper__\`;
	source = new EventSource(url);

	window.source = source;

	source.onopen = function (event) {
		console.log("[SAPPER] dev client connected");
	};

	source.onerror = function (error) {
		console.error(error);
	};

	source.onmessage = function (event) {
		const data = JSON.parse(event.data);
		if (!data) return; // just a heartbeat

		if (data.nonce && !nonce) {
			nonce = data.nonce;
		}

		if (data.nonce !== nonce || data.action === 'reload') {
			window.location.reload();
		}

		if (data.status === 'completed') {
			check();
		}
	};

	// Close the event source before the window is unloaded to prevent an error
	// ("The connection was interrupted while the page was loading.") in Firefox
	// when the page is reloaded.
	window.addEventListener('beforeunload', function () {
		source.close();
	});
}

connect(${dev_port});
}
` : ''}
	`.replace(/^\t{2}/gm, '').trim();
}



function generate_server_manifest(
	manifest_data: CodegenManifest,
	path_to_routes: string,
	path_to_template: string,
	dev: boolean,
	has_service_worker: boolean,
	shimport_version: string | null,
	get_file: (path_to_routes: string, component: PageComponent) => string,
) {
	const imports = new Array<string>().concat(
		manifest_data.server_routes.map((route, i) =>
			`import * as route_${i} from ${stringify(posixify(`${path_to_routes}/${route.file}`))};`),
		manifest_data.components.map((component, i) =>
			`import * as component_${i} from ${stringify(get_file(path_to_routes, component))};`),
		`import * as root from ${stringify(get_file(path_to_routes, manifest_data.root))};`,
		`import error from ${stringify(get_file(path_to_routes, manifest_data.error))};`,
		`import path from 'path'`,
	);

	const component_lookup: Record<string, number> = {};
	manifest_data.components.forEach((component, i) => {
		component_lookup[component.name] = i;
	});

	return `
		// This file is generated by Sapper — do not edit it!
		${imports.join('\n')}

		const d = decodeURIComponent;

		export const has_service_worker = ${JSON.stringify(has_service_worker)};

		export const manifest = {
			server_routes: [
				${manifest_data.server_routes.map((route, i) => `{
					// ${route.file}
					pattern: ${route.pattern},
					handlers: route_${i},
					params: ${route.params.length > 0
						? `match => ({ ${route.params.map(create_param_match).join(', ')} })`
						: `() => ({})`}
				}`).join(',\n\n\t\t\t\t')}
			],

			pages: [
				${manifest_data.pages.map(page => `{
					// ${page.parts[page.parts.length - 1].component.file}
					pattern: ${page.pattern},
					resources: ${[page.parts.filter(Boolean).map(part => part.component.file)].map(component_files =>
						component_files.length ? `"__SAPPER_RESOURCES_PLACEHOLDER:${component_files.join(":")}__"` : `[]`
					).join("")},
					parts: [
						${page.parts.map(part => {
							if (part === null) return 'null';

							const props = [
								`name: "${part.component.name}"`,
								`file: ${stringify(part.component.file)}`,
								`component: component_${component_lookup[part.component.name]}`,
							].filter(Boolean);

							if (part.params.length > 0) {
								const params = part.params.map(create_param_match);
								props.push(`params: match => ({ ${params.join(', ')} })`);
							}

							return `{ ${props.join(', ')} }`;
						}).join(',\n\t\t\t\t\t\t')}
					]
				}`).join(',\n\n\t\t\t\t')}
			],

			shimport_version: ${JSON.stringify(shimport_version)},
			main_resources: "__SAPPER_MAIN_RESOURCES_PLACEHOLDER__",
			main_legacy_resources: "__SAPPER_MAIN_LEGACY_RESOURCES_PLACEHOLDER__",

			root,
			error
		};

		export const assets_manifest = "__SAPPER_ASSETS_PLACEHOLDER__";

		// export let build_dir = path.join(path.relative(process.cwd(), __dirname), '..');

		// export function set_build_dir(s) {
		// 	build_dir = s
		// }

		export function read_template() {
			return ${dev && false ? // HACK(ajbouh) Don't read template from source directory.
					`fs.readFileSync("${path_to_template}", "utf-8")` :
					JSON.stringify(fs.readFileSync(path_to_template, 'utf-8'))
			};
		}

		export const dev = ${dev ? 'true' : 'false'};
	`.replace(/^\t{2}/gm, '').trim();
}

export function generate_app(
	manifest_data: CodegenManifest,
	path_to_routes: string,
	get_file: (path_to_routes: string, component: PageComponent) => string,
) {
	// TODO remove default layout altogether

	const max_depth = Math.max(1, ...manifest_data.pages.map(page => page.parts.filter(Boolean).length));

	const levels = [];
	for (let i = 0; i < max_depth; i += 1) {
		levels.push(i + 1);
	}

	let l = max_depth;

	let pyramid = `<svelte:component this="{level${l}.component}" {...level${l}.props}/>`;

	while (l-- > 1) {
		pyramid = `
			<svelte:component this="{level${l}.component}" segment="{segments[${l}]}" {...level${l}.props}>
				{#if level${l + 1}}
					${pyramid.replace(/\n/g, '\n\t\t\t\t\t')}
				{/if}
			</svelte:component>
		`.replace(/^\t\t\t/gm, '').trim();
	}

	return `
		<!-- This file is generated by Sapper — do not edit it! -->
		<script>
			import { setContext, afterUpdate } from 'svelte';
			import Layout from '${get_file(path_to_routes, manifest_data.root)}';

			export let stores;
			export let segments;
			export let level0;
			export let context_init;
			${levels.map(l => `export let level${l} = null;`).join('\n\t\t\t')}
			export let notify;

			afterUpdate(notify);
			context_init({setContext, stores})
		</script>

		<Layout segment="{segments[0]}" {...level0.props}>
			{#if level1}
			${pyramid.replace(/\n/g, '\n\t\t\t\t')}
			{/if}
		</Layout>
	`.replace(/^\t\t/gm, '').trim();
}

function get_file(path_to_routes: string, component: PageComponent) {
	if (component.default) return `./${component.type}.svelte`;
	return posixify(`${path_to_routes}/${component.file}`);
}
